//! Compare Rust ONNX embeddings against PyLate reference embeddings.
//!
//! This binary loads reference embeddings generated by PyLate and compares
//! them against the Rust ONNX implementation to verify correctness.

use anyhow::{Context, Result};
use ndarray::{Array1, Array2};
use onnx_experiment::{ColBertConfig, OnnxColBERT};
use serde::Deserialize;
use std::fs;

const MODEL_DIR: &str = "models";
const ONNX_MODEL_PATH: &str = "models/answerai-colbert-small-v1.onnx";
const TOKENIZER_PATH: &str = "models/tokenizer.json";
const REFERENCE_PATH: &str = "models/reference_embeddings.json";

#[derive(Deserialize, Debug)]
struct ReferenceEmbedding {
    text: String,
    is_query: bool,
    pylate_embeddings: Vec<Vec<f32>>,
    pylate_shape: Vec<usize>,
    onnx_embeddings: Vec<Vec<f32>>,
    onnx_shape: Vec<usize>,
    avg_cosine_similarity: f64,
    max_abs_difference: f64,
    input_ids: Vec<i64>,
}

fn vec_to_array2(v: &[Vec<f32>]) -> Array2<f32> {
    let rows = v.len();
    let cols = if rows > 0 { v[0].len() } else { 0 };
    let flat: Vec<f32> = v.iter().flatten().cloned().collect();
    Array2::from_shape_vec((rows, cols), flat).unwrap()
}

fn cosine_similarity(a: &Array1<f32>, b: &Array1<f32>) -> f32 {
    let dot: f32 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();
    let norm_a: f32 = a.iter().map(|x| x * x).sum::<f32>().sqrt();
    let norm_b: f32 = b.iter().map(|x| x * x).sum::<f32>().sqrt();
    if norm_a < 1e-9 || norm_b < 1e-9 {
        return 0.0;
    }
    dot / (norm_a * norm_b)
}

fn average_cosine_similarity(a: &Array2<f32>, b: &Array2<f32>) -> f32 {
    let min_len = a.nrows().min(b.nrows());
    if min_len == 0 {
        return 0.0;
    }
    let mut sum = 0.0f32;
    for i in 0..min_len {
        let row_a = a.row(i).to_owned();
        let row_b = b.row(i).to_owned();
        sum += cosine_similarity(&row_a, &row_b);
    }
    sum / min_len as f32
}

fn max_abs_difference(a: &Array2<f32>, b: &Array2<f32>) -> f32 {
    let min_rows = a.nrows().min(b.nrows());
    let min_cols = a.ncols().min(b.ncols());
    let mut max_diff = 0.0f32;
    for i in 0..min_rows {
        for j in 0..min_cols {
            let diff = (a[[i, j]] - b[[i, j]]).abs();
            if diff > max_diff {
                max_diff = diff;
            }
        }
    }
    max_diff
}

fn main() -> Result<()> {
    println!("=== Rust ONNX vs PyLate Comparison ===\n");

    // Check files exist
    if !std::path::Path::new(REFERENCE_PATH).exists() {
        eprintln!("Error: Reference embeddings not found at '{}'", REFERENCE_PATH);
        eprintln!("Please run: cd python && python generate_reference.py");
        return Ok(());
    }

    // Load config
    let config = ColBertConfig::from_model_dir(MODEL_DIR).ok();
    if let Some(ref cfg) = config {
        println!("Loaded config:");
        println!("  query_prefix: {:?}", cfg.query_prefix);
        println!("  document_prefix: {:?}", cfg.document_prefix);
        println!("  query_length: {}", cfg.query_length);
        println!("  document_length: {}", cfg.document_length);
        println!("  do_query_expansion: {}", cfg.do_query_expansion);
        println!("  skiplist_words: {} items", cfg.skiplist_words.len());
        println!();
    }

    // Load model
    println!("Loading ONNX model...");
    let mut model = OnnxColBERT::new(ONNX_MODEL_PATH, TOKENIZER_PATH, config, 4)?;

    // Load reference embeddings
    println!("Loading reference embeddings...\n");
    let content = fs::read_to_string(REFERENCE_PATH)
        .context("Failed to read reference embeddings")?;
    let references: Vec<ReferenceEmbedding> = serde_json::from_str(&content)?;

    println!("{:-<80}", "");

    let mut all_rust_vs_pylate_sims = Vec::new();
    let mut all_rust_vs_python_onnx_sims = Vec::new();
    let mut all_max_diffs = Vec::new();

    for reference in &references {
        let text_type = if reference.is_query { "QUERY" } else { "DOC  " };
        let short_text: String = reference.text.chars().take(50).collect();

        // Encode with Rust ONNX
        let rust_embeddings = if reference.is_query {
            model.encode(&[reference.text.as_str()], true)?
        } else {
            // For documents, use encode_with_tokens to get skiplist filtering
            let (embs, _) = model.encode_with_tokens(&[reference.text.as_str()], false, true)?;
            embs
        };
        let rust_emb = &rust_embeddings[0];

        // Get reference embeddings
        let pylate_emb = vec_to_array2(&reference.pylate_embeddings);
        let python_onnx_emb = vec_to_array2(&reference.onnx_embeddings);

        // Compare Rust ONNX vs PyLate
        let rust_vs_pylate_sim = average_cosine_similarity(rust_emb, &pylate_emb);
        let rust_vs_pylate_diff = max_abs_difference(rust_emb, &pylate_emb);

        // Compare Rust ONNX vs Python ONNX
        let rust_vs_python_onnx_sim = average_cosine_similarity(rust_emb, &python_onnx_emb);

        all_rust_vs_pylate_sims.push(rust_vs_pylate_sim);
        all_rust_vs_python_onnx_sims.push(rust_vs_python_onnx_sim);
        all_max_diffs.push(rust_vs_pylate_diff);

        println!("{} \"{}...\"", text_type, short_text);
        println!(
            "  Shapes: Rust={:?}, PyLate={:?}, Python ONNX={:?}",
            [rust_emb.nrows(), rust_emb.ncols()],
            reference.pylate_shape,
            reference.onnx_shape
        );
        println!(
            "  Rust vs PyLate:      cosine_sim={:.6}, max_diff={:.2e}",
            rust_vs_pylate_sim, rust_vs_pylate_diff
        );
        println!(
            "  Rust vs Python ONNX: cosine_sim={:.6}",
            rust_vs_python_onnx_sim
        );
        println!(
            "  Python ONNX vs PyLate: cosine_sim={:.6} (reference)",
            reference.avg_cosine_similarity
        );
        println!();
    }

    println!("{:-<80}", "");
    println!("\n=== SUMMARY ===\n");

    let avg_rust_vs_pylate: f32 =
        all_rust_vs_pylate_sims.iter().sum::<f32>() / all_rust_vs_pylate_sims.len() as f32;
    let avg_rust_vs_python_onnx: f32 =
        all_rust_vs_python_onnx_sims.iter().sum::<f32>() / all_rust_vs_python_onnx_sims.len() as f32;
    let max_diff: f32 = all_max_diffs.iter().cloned().fold(0.0f32, f32::max);

    println!("Average cosine similarities:");
    println!("  Rust ONNX vs PyLate:      {:.6}", avg_rust_vs_pylate);
    println!("  Rust ONNX vs Python ONNX: {:.6}", avg_rust_vs_python_onnx);
    println!("\nMax absolute difference (Rust vs PyLate): {:.2e}", max_diff);

    println!("\n=== CONCLUSION ===\n");

    if avg_rust_vs_pylate > 0.9999 {
        println!("SUCCESS: Rust ONNX produces IDENTICAL embeddings to PyLate!");
        println!(
            "The small differences ({:.2e}) are due to floating-point precision.",
            max_diff
        );
    } else if avg_rust_vs_pylate > 0.99 {
        println!("GOOD: Rust ONNX produces very similar embeddings to PyLate.");
        println!("Average cosine similarity: {:.6}", avg_rust_vs_pylate);
    } else {
        println!("WARNING: Embeddings differ significantly. Please investigate.");
        println!("Average cosine similarity: {:.6}", avg_rust_vs_pylate);
    }

    Ok(())
}
